	static constexpr bool hasCollision(float p1, float q1, float p2, float q2) {
		float min1 = min(p2, q2);
		float max1 = max(p2, q2);

		return  p1 >= min1 && p1 <= max1 ||
				q1 >= min1 && q1 <= max1 ||
				min(p1, q1) < min1 && max(p1, q1) > max1;
	}


	/**
	 * @param p1 - одна точка певой линии
	 * @param q1 - другая точка певой линии
	 * @param p1 - одна точка второй линии
	 * @param q1 - другая точка второй линии
	 * @return true, если линии пересекаются в точке или по отрезку, иначе false
	 */
	static constexpr bool hasCollision(
			const vec2& p1, const vec2& q1,
			const vec2& p2, const vec2& q2
	) {
		vec2 d1 = p1 - q1;
		vec2 d2 = p2 - q2;

		float c1 = d1.x == 0 ? INFINITY : d1.y / d1.x;
		float b1 = p1.y - p1.x * c1;

		float c2 = d2.x == 0 ? INFINITY : d2.y / d2.x;
		float b2 = p2.y - p2.x * c2;

		if (c1 == c2) {
			if (isinf(c1)) {
				return hasCollision(p1.y, q1.y, p2.y, q2.y);
			}

			return b1 == b2 && hasCollision(p1.x, q1.x, p2.x, q2.x);
		}

		float x = (b2 - b1) / (c1 - c2);
		return  x >= p1.x && x <= q1.x &&
				x >= p2.x && x <= q2.x;
	}

	static_assert(!hasCollision(vec2(0,1), vec2(1,2), vec2(4,4), vec2(2,2)));
	static_assert( hasCollision(vec2(0,1), vec2(1,2), vec2(1,2), vec2(2,2)));
	static_assert( hasCollision(vec2(0,0), vec2(1,1), vec2(0,1), vec2(1,0)));

	static_assert( hasCollision(vec2(0,0), vec2(0,1), vec2(0,1), vec2(0,2)));
	static_assert(!hasCollision(vec2(0,0), vec2(0,1), vec2(0,2), vec2(0,3)));
	
	static_assert( hasCollision(vec2(0,0), vec2(1,0), vec2(1,0), vec2(2,0)));
	static_assert(!hasCollision(vec2(0,0), vec2(1,0), vec2(2,0), vec2(3,0)));

	static_assert( hasCollision(vec2(0,0), vec2(0,0), vec2(0,0), vec2(0,0)));
	static_assert(!hasCollision(vec2(0,0), vec2(0,0), vec2(0,1), vec2(0,1)));


	static vec2 rotateVec2(const vec2& vec, float angle) {
		float sinA, cosA;
		sincosf(angle, &sinA, &cosA);

		return vec2(
			vec.x * cosA - vec.y * sinA,
			vec.x * sinA + vec.y * cosA
		);
	}